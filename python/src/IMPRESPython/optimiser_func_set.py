"""Set of functions to test unconstrained optimisation.
Generated by prompting O3-mini-high with:
```
Can you scrub this page: https://en.wikipedia.org/wiki/Test_functions_for_optimization
and convert all functions under the heading Test functions for single-objective optimization,
into python functions?
```
"""

import numpy as np


def ackley(x: np.ndarray) -> float:
    """
    Ackley function.

    Formula:
      f(x) = -20 exp( -0.2 sqrt((1/n) sum_i x_i^2) )
             - exp((1/n) sum_i cos(2π x_i)) + 20 + e

    Global minimum: f(0) = 0 at x = (0, 0, ..., 0)
    """
    x = np.asarray(x)
    n = x.size
    sum_sq = np.sum(x**2)
    sum_cos = np.sum(np.cos(2 * np.pi * x))
    term1 = -20.0 * np.exp(-0.2 * np.sqrt(sum_sq / n))
    term2 = -np.exp(sum_cos / n)
    return term1 + term2 + 20 + np.e


def alpine(x: np.ndarray) -> float:
    """
    Alpine function.

    Formula:
      f(x) = sum_i | x_i sin(x_i) + 0.1 x_i |

    Global minimum: f(0) = 0 at x = (0, 0, ..., 0)
    """
    x = np.asarray(x)
    return np.sum(np.abs(x * np.sin(x) + 0.1 * x))


def bukin_n6(point: np.ndarray) -> float:
    """
    Bukin Function N.6.

    Formula (for two variables):
      f(x, y) = 100 sqrt(| y - 0.01 x^2 |) + 0.01 | x + 10 |

    Global minimum: f(-10, 1) = 0
    """
    point = np.asarray(point)
    if point.size != 2:
        raise ValueError(
            "Bukin N.6 function is only defined for 2-dimensional input."
        )
    x, y = point
    return 100.0 * np.sqrt(np.abs(y - 0.01 * x**2)) + 0.01 * np.abs(x + 10)


def cosine_mixture(x: np.ndarray) -> float:
    """
    Cosine Mixture function.

    Formula:
      f(x) = -0.1 sum_i cos(5π x_i) - sum_i x_i sin(4π x_i) + sum_i x_i^2

    Global minimum: The exact minimum is not trivial to express.
    """
    x = np.asarray(x)
    term1 = -0.1 * np.sum(np.cos(5 * np.pi * x))
    term2 = -np.sum(x * np.sin(4 * np.pi * x))
    term3 = np.sum(x**2)
    return term1 + term2 + term3


def dixon_price(x: np.ndarray) -> float:
    """
    Dixon-Price function.

    Formula:
      f(x) = (x_1 - 1)^2 + sum_{i=2}^n [ i * (2x_i^2 - x_{i-1})^2 ]

    Global minimum: f(1, 1, ..., 1) = 0
    """
    x = np.asarray(x)
    n = x.size
    total = (x[0] - 1) ** 2
    for i in range(1, n):
        total += (i + 1) * (2 * x[i] ** 2 - x[i - 1]) ** 2
    return total


def eggholder(point: np.ndarray) -> float:
    """
    Eggholder function.

    Formula (for two variables):
      f(x, y) = - (y + 47) sin( sqrt(| x/2 + (y + 47) |) )
                - x sin( sqrt(| x - (y + 47) |) )

    Global minimum: Approximately f(x, y) ≈ -959.6407 at a point near (512, 404.2319)
    """
    point = np.asarray(point)
    if point.size != 2:
        raise ValueError(
            "Eggholder function is only defined for 2-dimensional input."
        )
    x, y = point
    term1 = -(y + 47) * np.sin(np.sqrt(np.abs(x / 2 + y + 47)))
    term2 = -x * np.sin(np.sqrt(np.abs(x - (y + 47))))
    return term1 + term2


def griewank(x: np.ndarray) -> float:
    """
    Griewank function.

    Formula:
      f(x) = 1 + (1/4000) sum_i x_i^2 - prod_i cos( x_i / sqrt(i) )

    Global minimum: f(0) = 0 at x = (0, 0, ..., 0)
    """
    x = np.asarray(x)
    sum_sq = np.sum(x**2) / 4000.0
    prod_cos = np.prod([np.cos(x[i] / np.sqrt(i + 1)) for i in range(x.size)])
    return 1 + sum_sq - prod_cos


def levy(x: np.ndarray) -> float:
    """
    Levy function.

    Let w_i = 1 + (x_i - 1)/4, then:
      f(x) = sin^2(π w_1) + sum_{i=1}^{n-1} (w_i - 1)^2 [ 1 + 10 sin^2(π w_i) ]
             + (w_n - 1)^2 [ 1 + sin^2(2π w_n) ]

    Global minimum: f(1,1,...,1) = 0
    """
    x = np.asarray(x)
    w = 1 + (x - 1) / 4.0
    term1 = np.sin(np.pi * w[0]) ** 2
    term3 = (w[-1] - 1) ** 2 * (1 + np.sin(2 * np.pi * w[-1]) ** 2)
    term2 = 0
    for i in range(len(x) - 1):
        term2 += (w[i] - 1) ** 2 * (1 + 10 * np.sin(np.pi * w[i]) ** 2)
    return term1 + term2 + term3


def michalewicz(x: np.ndarray, m: float = 10) -> float:
    """
    Michalewicz function.

    Formula:
      f(x) = - sum_{i=1}^n [ sin(x_i) * ( sin(i x_i^2 / π) )^(2m) ]

    Global minimum: Depends on the dimensionality.
    Parameter:
      m: steepness parameter (commonly m = 10)
    """
    x = np.asarray(x)
    indices = np.arange(1, x.size + 1)
    return -np.sum(np.sin(x) * (np.sin(indices * x**2 / np.pi) ** (2 * m)))


def perm_func(x: np.ndarray, beta: float = 0.5) -> float:
    """
    Perm function.

    Formula:
      f(x) = sum_{j=1}^n [ sum_{i=1}^n (i^j + beta)*((x_i/i)^j - 1) ]^2

    Global minimum: f(x) = 0 at a certain point (depending on beta)
    """
    x = np.asarray(x)
    n = x.size
    total = 0
    for j in range(1, n + 1):
        inner_sum = 0
        for i in range(1, n + 1):
            inner_sum += (i**j + beta) * ((x[i - 1] / i) ** j - 1)
        total += inner_sum**2
    return total


def powell(x: np.ndarray) -> float:
    """
    Powell function.

    Formula (for 4 variables):
      f(x) = (x_1 + 10 x_2)^2 + 5 (x_3 - x_4)^2 + (x_2 - 2 x_3)^4 + 10 (x_1 - x_4)^4

    Global minimum: f(x) = 0 at x = (0, 0, 0, 0)
    """
    x = np.asarray(x)
    if x.size != 4:
        raise ValueError(
            "Powell function is only defined for 4-dimensional input."
        )
    term1 = (x[0] + 10 * x[1]) ** 2
    term2 = 5 * (x[2] - x[3]) ** 2
    term3 = (x[1] - 2 * x[2]) ** 4
    term4 = 10 * (x[0] - x[3]) ** 4
    return term1 + term2 + term3 + term4


def rastrigin(x: np.ndarray) -> float:
    """
    Rastrigin function.

    Formula:
      f(x) = 10n + sum_i [ x_i^2 - 10 cos(2π x_i) ]

    Global minimum: f(0) = 0 at x = (0, 0, ..., 0)
    """
    x = np.asarray(x)
    n = x.size
    return 10 * n + np.sum(x**2 - 10 * np.cos(2 * np.pi * x))


def rosenbrock(x: np.ndarray) -> float:
    """
    Rosenbrock function.

    Formula:
      f(x) = sum_{i=1}^{n-1} [ 100 (x_{i+1} - x_i^2)^2 + (x_i - 1)^2 ]

    Global minimum: f(x) = 0 at x = (1, 1, ..., 1)
    """
    x = np.asarray(x)
    return np.sum(100.0 * (x[1:] - x[:-1] ** 2) ** 2 + (x[:-1] - 1) ** 2)


def derivative_rosenbrock(x: np.ndarray) -> np.ndarray:
    """Derivative of the Rosenbrock function.

    :param x: Function argument vector
    :return: Derivative of the function
    """
    df = np.empty_like(x)
    df[0] = -400 * x[0] * (x[1] - x[0] ** 2) - 2 * (1 - x[0])
    df[-1] = 200 * (x[-1] - x[-2] ** 2)
    df[1:-1] = (
        -400 * x[1:-1] * (x[2:] - x[1:-1] ** 2)
        - 2 * (1 - x[1:-1])
        + 200 * (x[1:-1] - x[:-2] ** 2)
    )
    return df


def schwefel(x: np.ndarray) -> float:
    """
    Schwefel function.

    Formula:
      f(x) = 418.9829 n - sum_i [ x_i sin( sqrt(|x_i|) ) ]

    Global minimum: Approximately f(x) = 0 at x_i ≈ 420.9687 for all i.
    """
    x = np.asarray(x)
    n = x.size
    return 418.9829 * n - np.sum(x * np.sin(np.sqrt(np.abs(x))))


def six_hump_camel(point: np.ndarray) -> float:
    """
    Six-Hump Camel function.

    Formula (for two variables):
      f(x, y) = (4 - 2.1 x^2 + x^4/3) x^2 + x y + (-4 + 4 y^2) y^2

    Global minima: Two points with f(x, y) ≈ -1.0316
    """
    point = np.asarray(point)
    if point.size != 2:
        raise ValueError(
            "Six-Hump Camel function is only defined for 2-dimensional input."
        )
    x, y = point
    return (4 - 2.1 * x**2 + x**4 / 3) * x**2 + x * y + (-4 + 4 * y**2) * y**2


def styblinski_tang(x: np.ndarray) -> float:
    """
    Styblinski–Tang function.

    Formula:
      f(x) = 0.5 sum_i [ x_i^4 - 16 x_i^2 + 5 x_i ]

    Global minimum: Approximately f(x) is minimised at x_i ≈ -2.903534 for all i.
    """
    x = np.asarray(x)
    return 0.5 * np.sum(x**4 - 16 * x**2 + 5 * x)


def zakharov(x: np.ndarray) -> float:
    """
    Zakharov function.

    Formula:
      f(x) = sum_i x_i^2 + ( sum_i 0.5 i x_i )^2 + ( sum_i 0.5 i x_i )^4

    Global minimum: f(0) = 0 at x = (0, 0, ..., 0)
    """
    x = np.asarray(x)
    sum_sq = np.sum(x**2)
    indices = np.arange(1, x.size + 1)
    linear_term = np.sum(0.5 * indices * x)
    return sum_sq + linear_term**2 + linear_term**4
